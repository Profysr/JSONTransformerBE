You did everything great, just messing up with readCodes and metrics Section. So, let me keep it simple for you, and we'll do it step by step.

ReadCodes:
Input Data: letter_codes_list
Configuration Rules: combination of general properties such as '"add_readcodes": "true"' and table such as specific_codes

Processing:
1- if add_readcodes = false, then return empty array of letter_codes_list, means our input is []
2- You can consider the rules other than table type are global. in simple words, it will be applicable to all the codes, present in the input + specific_codes table.
3- When processing the specific_codes table, remember that for each row, we've another skipField that is addCodes. if its false, there came 2 scenarios:
    don't add the row to the output. 
    if the row already exists in the letter_codes_list (our input), remove it from there
if its true, add the row to the output.

4- after processing the specific_codes table, return the letter_codes_list, pendingForcedCodeMappings
5- Now, you've to process the general properties to each of the codes in the letter_codes_list, and apply external methods such that forcedCodeMappings.
6- For the readCodes, the local context will be the each object in the letter_codes_list

Metrics:
But when came to metrics, things are pretty simple in comparison to readCodes. 

1- The whole metrics object will be the context
2- For each row, we've a skipField 'add_metric' that is boolean. if its false, don't add the row to the output. if its true, add the row to the output.


Conclusion:
You need to update the codes as it should combine the similar things in functions and write it down for both sections. Yeah, the different things, we've 2 separate files for it, you can define them there. The files are 'SectionRegistry' and 'RowProcessors'. 

If you don't understand what I'mm saying, ask me the quesitons. Ask questions as much you want But don't ruin the tokens, my time and the project.

For these changes, you may need to updates these files:
tableProcessor.js, SectionRegistry.js, RowProcessors.js, GenericEngine.js, templateEngine.js







Input vs Seeding: I'm not sure what are you meant by seeding. But there is a field present in the inputData (letter_codes_list - an array of objects)

Specific_codes table processing:
When addCodes = false and the row exists in letter_codes_list, should we remove it by matching on code field -- yes you can remove the row by matching meta.identifier
When addCodes = true, should we add the row even if it already exists in letter_codes_list - if the row already exists in the letter_codes_liist, modify it, instead of creating duplicates

General properties application: You mentioned "apply external methods such as forcedCodeMappings" - should this happen:
Before or after processing the specific_codes table?

I belive, it should happen after processing specific_codes. Because when end up everything, then you can map codes easily. 

What exactly is pendingForcedCodeMappings that you want returned in step 4?
For example: if you see my input.json, there are some rules defined. ForcedCodeMappings is one of them, that will be present with each row. During table processing, you've to return those mappings and at the end, call the function to map the codes. 

Local context: When you say "the local context will be each object in letter_codes_list" - do you mean:
When applying general properties, we evaluate rules/transforms against each individual code object? --- yes, you're right


Questions about Metrics Processing:
Context scope: When you say "the whole metrics object will be the context" - do you mean:
The entire metrics section configuration is the context for rule evaluation?
Or the accumulated metrics output object?
No, there will be a field present in the inputData as we've letter_codes_liist. It is a object as:
metrics:{
    height:_,
    weight:-,
    ...
}

Table processing: For metrics table rows:
Should we still seed from template first, then process the table?
Or is there no seeding for metrics at all?

I guess, for metrics, there will be no itemMapping. Because it's already an object. How can you map height to height as you do for letter_codes_liist <child>: {
    ...
}?

Questions about Code Structure:
Shared vs Separate logic:
What specific logic should be shared between readCodes and metrics? (e.g., rule evaluation, field transformation, skip field handling?)

You know better. Create the logic as we can scale them. And separate out the things that needs to be hard-coded. For example: for the readCodes, we've skip identifier for add_readcodes as a general or addCodes for each row 

